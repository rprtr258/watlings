const n=JSON.parse('[{"id":"1-basics","title":"Basics","lessons":[{"id":"hello","title":"Hello","instructionsHtml":"<p>We often export and import when writing WASM.<br>Here we import a function called $log_num that takes in one i32 as its only parameter<br>We import it from the namespace \\"env\\" under the name \\"log\\" and call it $log_num locally</p>\\n<p>Calling a function uses the syntax (call $func_name (param1) (param2) ...)<br>Number literals use the form: (TYPE.const NUMBER)<br>e.g. (f64.const 1093.31) or (i32.const -3029)</p>\\n<p>Call $log_num with the 32-bit integer 42.</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_num (param i32)))\\n\\n  (func $main\\n    ;; TODO: call $log_num here\\n  )\\n\\n  (start $main)\\n)","solutionCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_num (param i32)))\\n\\n  (func $main\\n    (call $log_num (i32.const 42))\\n  )\\n\\n  (start $main)\\n)","testCode":"","hasWasm":false},{"id":"ordering","title":"Ordering","instructionsHtml":"<p>WASM supports S-expressions and regular stack-based parameter handling.</p>\\n<p>If we wish, we can write WAT like this:</p>\\n<pre><code>i32.const 2   ;; push 2_i32 to the stack\\ni32.const 18  ;; push 18_i32 to the stack\\ni32.sub       ;; subtract the last 2 numbers and put it back on the stack (-16)\\ni32.const 6   ;; push 6_i32 to the stack\\ni32.sub       ;; subtract the last 2 numbers and put it back on the stack (-22)\\ncall $log_num ;; call $log_num with the last number on the stack</code></pre>\\n<p>For clarity, we can instead write it like</p>\\n<pre><code>(call $log_num\\n  (i32.sub\\n    (i32.sub (i32.const 2) (i32.const 18))\\n    (i32.const 6))\\n)</code></pre>\\n<p>Call log_nums with the arguments (in order) of 1, 2, 3. Try it both ways!</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_nums (param i32) (param i32) (param i32)))\\n\\n  (func $main\\n      ;; TODO: call $log_nums here\\n  )\\n\\n  (start $main)\\n)","solutionCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_nums (param i32) (param i32) (param i32)))\\n\\n  (func $main\\n    (call $log_nums (i32.const 1) (i32.const 2) (i32.const 3))\\n  )\\n\\n  (start $main)\\n)","testCode":"","hasWasm":false},{"id":"export","title":"Export","instructionsHtml":"<p>Our $main function is being called automatically. This might not be desirable.</p>\\n<p>We can export a function using the syntax:</p>\\n<pre><code>(export \\"exportName\\" (func $func_name))</code></pre>\\n<p>If we don\'t need to call our function internally, we can export it while defining:</p>\\n<pre><code>(func (export \\"exportName\\")\\n  (call $log_num (i32.const 42))\\n)</code></pre>\\n<p>Export our $main function with the name \\"main\\" instead of calling it immediately.</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_num (param i32)))\\n\\n  (func $main\\n    (call $log_num (i32.const 42))\\n  )\\n\\n  ;; TODO: replace this with an export\\n  (start $main)\\n)","solutionCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_num (param i32)))\\n\\n  (func $main\\n    (call $log_num (i32.const 42))\\n  )\\n\\n  (export \\"main\\" (func $main))\\n)","testCode":"","hasWasm":false}]},{"id":"2-functions-and-types","title":"Functions & Types","lessons":[{"id":"function","title":"Function","instructionsHtml":"<p>Functions can define parameters and return types.</p>\\n<p>A return type is defined with a <code>(result TYPE)</code> expression, such as:</p>\\n<pre><code>(func $get_num (result i32) (i32.const 42))</code></pre>\\n<p>Parameters are defined with <code>(param TYPE)</code> or <code>(param $param_name TYPE)</code></p>\\n<pre><code>(func $log_wasm (param i32) (call $log_num (local.get 0)))\\n(func $log_wasm (param $a i32) (call $log_num (local.get $a)))</code></pre>\\n<p>A parameter can be retrieved with (local.get $param_name)<br>If the parameter was not given a name, it can be 0-indexed<br>i.e. (local.get 0) is the 1st param</p>\\n<p>Implement the $sub and $mul functions using i32.sub and i32.mul</p>","exerciseCode":"(module\\n  ;; A function that returns the number 42\\n  (func $get_num (result i32) (i32.const 42))\\n  ;; A function that returns the number it\'s given\\n  (func $get_num_2 (param i32) (result i32)\\n    (local.get 0)\\n  )\\n\\n  ;; A function that adds 2 numbers, a and b\\n  (func $add\\n    (param $a i32) (param $b i32)\\n    (result i32)\\n\\n    ;; The last stack value is the return value\\n    (i32.add (local.get $a) (local.get $b))\\n  )\\n\\n  ;; TODO: fill in the blanks!\\n  (func $sub)\\n  (func $mul)\\n\\n  (export \\"add\\" (func $add))\\n  (export \\"sub\\" (func $sub))\\n  (export \\"mul\\" (func $mul))\\n)","solutionCode":"(module\\n  ;; A function that returns the number 42\\n  (func $get_num (result i32) (i32.const 42))\\n  ;; A function that returns the number it\'s given\\n  (func $get_num_2 (param i32) (result i32)\\n    (local.get 0)\\n  )\\n\\n  ;; A function that adds 2 numbers, a and b\\n  (func $add\\n    (param $a i32) (param $b i32)\\n    (result i32)\\n\\n    ;; The last stack value is the return value\\n    (i32.add (local.get $a) (local.get $b))\\n  )\\n\\n  (func $sub\\n    (param $a i32) (param $b i32)\\n    (result i32)\\n    (i32.sub (local.get $a) (local.get $b))\\n  )\\n  (func $mul\\n    (param $a i32) (param $b i32)\\n    (result i32)\\n\\n    (i32.mul (local.get $a) (local.get $b))\\n  )\\n\\n  (export \\"add\\" (func $add))\\n  (export \\"sub\\" (func $sub))\\n  (export \\"mul\\" (func $mul))\\n)","testCode":"","hasWasm":false},{"id":"variables","title":"Variables","instructionsHtml":"<p>Variables must be declared before use. They can either be global or local.</p>\\n<p>Syntax:</p>\\n<pre><code>(global/local $var_name TYPE init_expr)\\n(global/local.get $var_name)\\n(global/local.set $var_name (VALUE))</code></pre>\\n<p>Global variables must be marked as (mut TYPE) if we want them to be editable.</p>\\n<p>Finish the doubleGlobal function.</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"global_num\\" (global $global_num_import (mut i32)))\\n\\n  (global $local_global (mut i32) (i32.const 0))\\n\\n  (func (export \\"incGlobal\\") (result i32)\\n    ;; $local_global = $local_global + 1\\n    (global.set $local_global (i32.add (global.get $local_global) (i32.const 1)))\\n\\n    (global.get $local_global)\\n  )\\n\\n  (func (export \\"doubleGlobal\\") (result i32)\\n    ;; all variables must be declared first before any other ops\\n    (local $local_num i32)\\n\\n    ;; TODO: set $local_num to be double the value of $global_num_import\\n\\n    (local.get $local_num)\\n  )\\n)","solutionCode":"(module\\n  (import \\"env\\" \\"global_num\\" (global $global_num_import (mut i32)))\\n\\n  (global $local_global (mut i32) (i32.const 0))\\n\\n  (func (export \\"incGlobal\\") (result i32)\\n    ;; $local_global = $local_global + 1\\n    (global.set $local_global (i32.add (global.get $local_global) (i32.const 1)))\\n\\n    (global.get $local_global)\\n  )\\n\\n  (func (export \\"doubleGlobal\\") (result i32)\\n    ;; all variables must be declared first before any other ops\\n    (local $local_num i32)\\n\\n    (local.set $local_num (i32.mul (global.get $global_num_import) (i32.const 2)))\\n\\n    (local.get $local_num)\\n  )\\n)","testCode":"","hasWasm":false},{"id":"numbers","title":"Numbers","instructionsHtml":"<p>Numbers can be of type: i32, i64, f32, f64<br>Choosing a type has ergonomic consequences. It is very difficult to change later down the line.<br>The memory layout and maximum value of a f32 is very different from an i32.</p>\\n<p>We cannot use an i32.add on an f32 without first converting it. There is no implicit conversion.</p>\\n<p>When converting, we must also be aware of whether our ints are signed. An op will end with <code>_s</code> or <code>_u</code> if it is sign-aware.</p>\\n<pre><code>i32.trunc_f32_s -&gt; f32 to i32 (signed)\\nf32.convert_i32_s -&gt; i32 to f32 (signed)</code></pre>\\n<p>You can see all the conversion operations on https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/Numeric#conversion</p>\\n<p>Implement double_init by using double_float (and converting between types twice)</p>","exerciseCode":"(module\\n  ;; do not edit this\\n  (func $double_float (param $float_num f32) (result f32)\\n    (f32.mul (local.get $float_num) (f32.const 2))\\n  )\\n\\n  ;; do not edit the header\\n  (func $double_int (param $num i32) (result i32)\\n    ;; TODO: double the value using double_float\\n  )\\n\\n  (export \\"doubleInt\\" (func $double_int))\\n  (export \\"doubleFloat\\" (func $double_float))\\n)","solutionCode":"(module\\n  ;; do not edit this\\n  (func $double_float (param $float_num f32) (result f32)\\n    (f32.mul (local.get $float_num) (f32.const 2))\\n  )\\n\\n  ;; do not edit the header\\n  (func $double_int (param $num i32) (result i32)\\n    (i32.trunc_f32_s\\n      (call $double_float\\n        (f32.convert_i32_s (local.get $num))\\n      )\\n    )\\n  )\\n\\n  (export \\"doubleInt\\" (func $double_int))\\n  (export \\"doubleFloat\\" (func $double_float))\\n)","testCode":"","hasWasm":false}]},{"id":"3-control-flow","title":"Control Flow","lessons":[{"id":"conditionals","title":"Conditionals","instructionsHtml":"<p>With conditional operators (e.g. if and select), 0 is false and non-zero is true.</p>\\n<p><code>if</code> takes 2 or 3 arguments. We will be writing it like this:</p>\\n<pre><code>(if\\n  (VALUE_FOR_CONDITIONAL)\\n  (then\\n    ;; if non-zero\\n  )\\n  (else\\n    ;; if-zero\\n  )\\n)</code></pre>\\n<p>Note that we can also write it like this:</p>\\n<pre><code>(VALUE_FOR_CONDITIONAL)\\nif\\n  ;; if non-zero\\nelse\\n  ;; if-zero\\nend</code></pre>\\n<p>If we want a value instead of an action, try <code>select</code>:</p>\\n<pre><code>(select (NON_ZERO_VALUE) (ZERO_VALUE) (CONDITIONAL))</code></pre>\\n<p>It may be useful to use (return (VALUE)) at some point.<br>This allows for early termination of a function.</p>\\n<p>Finish the <code>getNum</code> function.</p>","exerciseCode":"(module\\n  ;; Look ma, no boolean!\\n  (func $is_even (param $num i32) (result i32)\\n    ;; put on stack: $num % 2 === 0\\n    (i32.eqz (i32.rem_u (local.get $num) (i32.const 2)))\\n  )\\n\\n  ;; build (select ...) using (if ...)\\n  (func $custom_select\\n    (param $if_value i32) (param $else_value i32) (param $conditional i32)\\n    (result i32)\\n\\n    (local $return_value i32)\\n\\n    (if\\n      (local.get $conditional)\\n      (then\\n        (local.set $return_value (local.get $if_value))\\n      )\\n      (else\\n        (local.set $return_value (local.get $else_value))\\n      )\\n    )\\n\\n    (local.get $return_value)\\n  )\\n\\n  (func (export \\"getNum\\") (param $num i32) (result i32)\\n    ;; TODO:\\n    ;; return 42 if even, 100 if odd\\n  )\\n\\n  (export \\"isEven\\" (func $is_even))\\n)","solutionCode":"(module\\n  ;; Look ma, no boolean!\\n  (func $is_even (param $num i32) (result i32)\\n    ;; put on stack: $num % 2 === 0\\n    (i32.eqz (i32.rem_u (local.get $num) (i32.const 2)))\\n  )\\n\\n  ;; build (select ...) using (if ...)\\n  (func $custom_select\\n    (param $if_value i32) (param $else_value i32) (param $conditional i32)\\n    (result i32)\\n\\n    (local $return_value i32)\\n\\n    (if\\n      (local.get $conditional)\\n      (then\\n        (local.set $return_value (local.get $if_value))\\n      )\\n      (else\\n        (local.set $return_value (local.get $else_value))\\n      )\\n    )\\n\\n    (local.get $return_value)\\n  )\\n\\n  (func (export \\"getNum\\") (param $num i32) (result i32)\\n    (select (i32.const 42) (i32.const 100) (call $is_even (local.get $num)))\\n    ;; OR\\n    ;; (if (result i32)\\n    ;;   (call $is_even (local.get $num))\\n    ;;   (then (i32.const 42))\\n    ;;   (else (i32.const 100))\\n    ;; )\\n  )\\n\\n  (export \\"isEven\\" (func $is_even))\\n)","testCode":"","hasWasm":false},{"id":"loops","title":"Loops","instructionsHtml":"<p>Loops can be created using labels and branching.</p>\\n<p>Here is a quick infinite-loop (do not recreate):</p>\\n<pre><code>(loop $loop_name\\n  (br $loop_name) ;; jump to $loop_name label\\n)</code></pre>\\n<p>Both <code>loop</code> and <code>block</code> create jump points (labels) which we can branch to at some point.<br>A <code>loop</code> creates a label at the start, so a jump will go back to the entry.<br>A <code>block</code> creates a label at the end, so a jump will go forward to the exit.</p>\\n<pre><code>(block $block_name\\n  (br $block_name)\\n  (call $some_function) ;; this is never called\\n)</code></pre>\\n<p>You can conditionally branch by placing a <code>br</code> inside an (if ...) or by using br_if</p>\\n<p>Implement $count_even_until according to the comment.</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_num (param i32)))\\n\\n  ;; example function\\n  (func $count_down (param $num i32)\\n    (loop $count_loop\\n      ;; $num = $num - 1\\n      (local.set $num\\n        (i32.sub (local.get $num) (i32.const 1))\\n      )\\n\\n      (call $log_num (local.get $num))\\n\\n      ;; branch if: $num > 0\\n      (i32.gt_s (local.get $num) (i32.const 0))\\n      (br_if $count_loop)\\n    )\\n  )\\n\\n  ;; example function\\n  (func $count_until (param $end i32)\\n    (local $num i32)\\n    (local.set $num (i32.const 0))\\n\\n    (loop $count_loop\\n      (block $break_loop\\n\\n        (call $log_num (local.get $num))\\n\\n        ;; $num = $num + 1\\n        (local.set $num\\n          (i32.add (local.get $num) (i32.const 1))\\n        )\\n\\n        ;; exit early if $num === $end (do not log last number)\\n        (i32.eq (local.get $num) (local.get $end))\\n        (br_if $break_loop)\\n\\n        ;; loop again\\n        (br $count_loop)\\n        ;; NOTE: We obviously did not need `block` here. We could just use br_if for $count_loop.\\n        ;; In fact, We never really need `block`, but it sometimes helps with ergonomics.\\n      )\\n    )\\n  )\\n\\n  (func $count_even_until (param $end i32)\\n    ;; TODO: call $log_num for every even number starting at 0.\\n    ;; Log until $end exclusive (do not log $end)\\n  )\\n\\n  (export \\"countDown\\" (func $count_down))\\n  (export \\"countUntil\\" (func $count_until))\\n  (export \\"countEvenUntil\\" (func $count_even_until))\\n)\\n","solutionCode":"(module\\n  (import \\"env\\" \\"log\\" (func $log_num (param i32)))\\n\\n  ;; example function\\n  (func $count_down (param $num i32)\\n    (loop $count_loop\\n      ;; $num = $num - 1\\n      (local.set $num\\n        (i32.sub (local.get $num) (i32.const 1))\\n      )\\n\\n      (call $log_num (local.get $num))\\n\\n      ;; branch if: $num > 0\\n      (i32.gt_s (local.get $num) (i32.const 0))\\n      (br_if $count_loop)\\n    )\\n  )\\n\\n  ;; example function\\n  (func $count_until (param $end i32)\\n    (local $num i32)\\n    (local.set $num (i32.const 0))\\n\\n    (loop $count_loop\\n      (block $break_loop\\n\\n        (call $log_num (local.get $num))\\n\\n        ;; $num = $num + 1\\n        (local.set $num\\n          (i32.add (local.get $num) (i32.const 1))\\n        )\\n\\n        ;; exit early if $num === $end (do not log last number)\\n        (i32.eq (local.get $num) (local.get $end))\\n        (br_if $break_loop)\\n\\n        ;; loop again\\n        (br $count_loop)\\n        ;; NOTE: We obviously did not need `block` here. We could just use br_if for $count_loop.\\n        ;; In fact, We never really need `block`, but it sometimes helps with ergonomics.\\n      )\\n    )\\n  )\\n\\n  (func $count_even_until (param $end i32)\\n    (local $num i32)\\n    (local.set $num (i32.const 0))\\n\\n    (loop $count_loop (block $break_loop\\n      (if\\n        (i32.eq (local.get $num) (local.get $end))\\n        (then (br $break_loop))\\n      )\\n\\n      (call $log_num (local.get $num))\\n      (local.set $num (i32.add (local.get $num) (i32.const 2)))\\n\\n      (br $count_loop)\\n    ))\\n  )\\n\\n  (export \\"countDown\\" (func $count_down))\\n  (export \\"countUntil\\" (func $count_until))\\n  (export \\"countEvenUntil\\" (func $count_even_until))\\n)\\n","testCode":"","hasWasm":false}]},{"id":"4-data-and-memory","title":"Data & Memory","lessons":[{"id":"data","title":"Data","instructionsHtml":"<p>We can inline data by using utf-8 strings and the <code>data</code> instruction:</p>\\n<pre><code>(data (i32.const OFFSET) \\"TEXT DATA\\")</code></pre>\\n<p>This can be regular string data or binary blobs (via escape sequences)</p>\\n<p>Inlining data requires memory, which we can request using <code>(memory NUMBER)</code></p>\\n<p>Export a function called $log_data that logs any 3 different strings.</p>","exerciseCode":"(module\\n  ;; function that logs strings using start index and length\\n  (import \\"env\\" \\"log_string\\" (func $log_string (param i32) (param i32)))\\n\\n  ;; request 1 page (64KB) of memory, call it $mem\\n  (memory 1)\\n\\n  (data (i32.const 0) \\"Hello, World!\\\\n\\") ;; inline 14 bytes at offset 0\\n  (data (i32.const 20) \\"Woah, radical!\\\\n\\") ;; inline 15 bytes at offset 20\\n\\n  ;; TODO: export a function $log_data that logs 3 different strings\\n  ;; It should make calls to $log_string\\n\\n  (export \\"logData\\" (func $log_data))\\n  (export \\"mem\\" (memory 0))\\n)","solutionCode":"(module\\n  ;; function that logs strings using start index and length\\n  (import \\"env\\" \\"log_string\\" (func $log_string (param i32) (param i32)))\\n\\n  ;; request 1 page (64KB) of memory, call it $mem\\n  (memory 1)\\n\\n  (data (i32.const 0) \\"Hello, World!\\\\n\\") ;; inline 14 bytes at offset 0\\n  (data (i32.const 20) \\"Woah, radical!\\\\n\\") ;; inline 15 bytes at offset 20\\n\\n  (func $log_data\\n    (call $log_string (i32.const 0) (i32.const 14)) ;; first string\\n    (call $log_string (i32.const 20) (i32.const 15)) ;; second string\\n    (call $log_string (i32.const 0) (i32.const 5)) ;; part of first string\\n  )\\n\\n  (export \\"logData\\" (func $log_data))\\n  (export \\"mem\\" (memory 0))\\n)","testCode":"","hasWasm":false},{"id":"memory","title":"Memory","instructionsHtml":"<p>How do we return arrays? How do we quickly generate data?<br>Instead of just returning a number, what about sharing some block of memory?<br>The host can write some input, call us, and then read the result.</p>\\n<p>While we only have 32 and 64 bit numbers, we often deal in \\"bytes\\"<br>We store and retrieve bytes from our global memory block by using</p>\\n<pre><code>(i32.store8 (INDEX) (VALUE)) and (i32.load8_u (INDEX))</code></pre>\\n<p>Implement $double_data which doubles every integer in the memory range provided</p>","exerciseCode":"(module\\n  ;; Get from host via import instead of exporting our own\\n  (import \\"env\\" \\"mem\\" (memory 1)) ;; 1 page = 64KB\\n\\n  (func $increment_data (param $start i32) (param $end i32)\\n    (local $index i32)\\n    (local $cur_num i32)\\n\\n    ;; $index = $start\\n    (local.set $index (local.get $start))\\n\\n    (loop $loop_name\\n      ;; mem[$index] = mem[$index] + 1\\n      (i32.store8\\n        (local.get $index)\\n        (i32.add\\n          (i32.load8_u (local.get $index)) ;; mem[$index]\\n          (i32.const 1)\\n        )\\n      )\\n\\n      ;; $index = $index + 1\\n      (local.set $index (i32.add (local.get $index) (i32.const 1)))\\n\\n      ;; loop if $index < $end\\n      (i32.lt_u (local.get $index) (local.get $end))\\n      (br_if $loop_name)\\n    )\\n  )\\n\\n  (func $double_data (param $start i32) (param $end i32)\\n    ;; double all the values within the index range [$start, $end]\\n  )\\n\\n  (export \\"incrementData\\" (func $increment_data))\\n  (export \\"doubleData\\" (func $double_data))\\n)","solutionCode":"(module\\n  ;; Get from host via import instead of exporting our own\\n  (import \\"env\\" \\"mem\\" (memory 1)) ;; 1 page = 64KB\\n\\n  (func $increment_data (param $start i32) (param $end i32)\\n    (local $index i32)\\n    (local $cur_num i32)\\n\\n    ;; $index = $start\\n    (local.set $index (local.get $start))\\n\\n    (loop $loop_name\\n      ;; mem[$index] = mem[$index] + 1\\n      (i32.store8\\n        (local.get $index)\\n        (i32.add\\n          (i32.load8_u (local.get $index)) ;; mem[$index]\\n          (i32.const 1)\\n        )\\n      )\\n\\n      ;; $index = $index + 1\\n      (local.set $index (i32.add (local.get $index) (i32.const 1)))\\n\\n      ;; loop if $index < $end\\n      (i32.lt_u (local.get $index) (local.get $end))\\n      (br_if $loop_name)\\n    )\\n  )\\n\\n  (func $double_data (param $start i32) (param $end i32)\\n    (local $index i32)\\n    (local.set $index (local.get $start))\\n\\n    (loop $loop_name\\n      (i32.store8 ;; mem[$index] = mem[$index] * 2\\n        (local.get $index)\\n        (i32.mul ;; mem[$index] * 2\\n          (i32.const 2)\\n          (i32.load8_u (local.get $index))\\n        )\\n      )\\n\\n      ;; $index = $index + 1\\n      (local.set $index (i32.add (local.get $index) (i32.const 1)))\\n\\n      ;; loop if $index < $end\\n      (i32.lt_u (local.get $index) (local.get $end))\\n      (br_if $loop_name)\\n    )\\n  )\\n\\n  (export \\"incrementData\\" (func $increment_data))\\n  (export \\"doubleData\\" (func $double_data))\\n)","testCode":"","hasWasm":false}]},{"id":"5-host-integration","title":"Host Integration","lessons":[{"id":"host","title":"Host","instructionsHtml":"<p>This exercise just exists to get better at interop between the host environment and wasm.</p>\\n<p>There is nothing you must edit here, but feel free to play around!</p>\\n<p>You will find more detailed comments in the associated JS file.</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"memory\\" (memory 1))\\n  (import \\"env\\" \\"log\\" (func $log (param i32)))\\n\\n  (func $square_num (param i32) (result i32)\\n    (i32.mul (local.get 0) (local.get 0))\\n  )\\n\\n  (func $log_some_numbers\\n    (call $log (i32.const 1))\\n    (call $log (i32.const 42))\\n    (call $log (i32.const 88))\\n  )\\n\\n  (func $edit_memory\\n    (local $index i32)\\n    (local $end i32)\\n\\n    (local.set $index (i32.const 0))\\n    (local.set $end (i32.const 500))\\n\\n    (loop $loop_name\\n      (i32.store8\\n        (local.get $index)\\n        (i32.mul\\n          (i32.load8_u (local.get $index))\\n          (i32.const 2)\\n        )\\n      )\\n\\n      (local.set $index (i32.add (local.get $index) (i32.const 1)))\\n      (i32.lt_u (local.get $index) (local.get $end))\\n      (br_if $loop_name)\\n    )\\n  )\\n\\n  (export \\"squareNum\\" (func $square_num))\\n  (export \\"logSomeNumbers\\" (func $log_some_numbers))\\n  (export \\"editMemory\\" (func $edit_memory))\\n)","solutionCode":"(module\\n  (import \\"env\\" \\"memory\\" (memory 1))\\n  (import \\"env\\" \\"log\\" (func $log (param i32)))\\n\\n  (func $square_num (param i32) (result i32)\\n    (i32.mul (local.get 0) (local.get 0))\\n  )\\n\\n  (func $log_some_numbers\\n    (call $log (i32.const 1))\\n    (call $log (i32.const 42))\\n    (call $log (i32.const 88))\\n  )\\n\\n  (func $edit_memory\\n    (local $index i32)\\n    (local $end i32)\\n\\n    (local.set $index (i32.const 0))\\n    (local.set $end (i32.const 500))\\n\\n    (loop $loop_name\\n      (i32.store8\\n        (local.get $index)\\n        (i32.mul\\n          (i32.load8_u (local.get $index))\\n          (i32.const 2)\\n        )\\n      )\\n\\n      (local.set $index (i32.add (local.get $index) (i32.const 1)))\\n      (i32.lt_u (local.get $index) (local.get $end))\\n      (br_if $loop_name)\\n    )\\n  )\\n\\n  (export \\"squareNum\\" (func $square_num))\\n  (export \\"logSomeNumbers\\" (func $log_some_numbers))\\n  (export \\"editMemory\\" (func $edit_memory))\\n)","testCode":"","hasWasm":false,"hostCode":"// The configuration object also allows has \\"maximum\\" and \\"shared\\"\\n// https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory\\nconst memory = new WebAssembly.Memory({ initial: 1 });\\nconst imports = {\\n  env: {\\n    memory,\\n    log: console.log,\\n  },\\n};\\n\\nconst {instance} = await WebAssembly.instantiate(wasmBytes, imports);\\n\\n// pull out wasm exports\\nconst {squareNum, logSomeNumbers, editMemory} = instance.exports as {\\n  squareNum: (num: number) => number;\\n  logSomeNumbers: () => void;\\n  editMemory: (start: number, end: number) => void;\\n};\\n\\nconst squareOf5 = squareNum(5);\\nconsole.log({squareOf5}); // {squareOf5: 25}\\n\\nlogSomeNumbers(); // 1, 42, 88\\n\\n// Edit a JS dataview into shared memory\\nconst dataView = new Uint8Array(memory.buffer);\\nfor (let i = 0; i < 20; i++)\\n  dataView[i] = i;\\n\\nconsole.log(dataView.slice(0, 20).join(\\" \\"));\\neditMemory(0, 20);\\nconsole.log(dataView.slice(0, 20).join(\\" \\"));\\neditMemory(0, 20);\\nconsole.log(dataView.slice(0, 20).join(\\" \\"));","hostSolutionCode":"// The configuration object also allows has \\"maximum\\" and \\"shared\\"\\n// https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory\\nconst memory = new WebAssembly.Memory({ initial: 1 });\\nconst imports = {\\n  env: {\\n    memory,\\n    log: console.log,\\n  },\\n};\\n\\nconst {instance} = await WebAssembly.instantiate(wasmBytes, imports);\\n\\n// pull out wasm exports\\nconst {squareNum, logSomeNumbers, editMemory} = instance.exports as {\\n  squareNum: (num: number) => number;\\n  logSomeNumbers: () => void;\\n  editMemory: (start: number, end: number) => void;\\n};\\n\\nconst squareOf5 = squareNum(5);\\nconsole.log({squareOf5}); // {squareOf5: 25}\\n\\nlogSomeNumbers(); // 1, 42, 88\\n\\n// Edit a JS dataview into shared memory\\nconst dataView = new Uint8Array(memory.buffer);\\nfor (let i = 0; i < 20; i++)\\n  dataView[i] = i;\\n\\nconsole.log(dataView.slice(0, 20).join(\\" \\"));\\neditMemory(0, 20);\\nconsole.log(dataView.slice(0, 20).join(\\" \\"));\\neditMemory(0, 20);\\nconsole.log(dataView.slice(0, 20).join(\\" \\"));"}]},{"id":"6-advanced-features","title":"Advanced Features","lessons":[{"id":"reftypes","title":"Reftypes","instructionsHtml":"<p>In addition to the 4 number types, we also have 2 \\"ref\\" types:</p>\\n<pre><code>- externref: any reference or null\\n- funcref: a reference to a function or null</code></pre>\\n<p>We can\'t view or modify the underlying values, but we can pass them around!</p>\\n<p>This brings us to 3 new operations:</p>\\n<pre><code>- (ref.func $func_id): make a reference from a local function (only valid if function is in a table)\\n- (ref.null extern/func): make a null reference for an extern or func\\n- (ref.is_null $id): check if reference is currently null</code></pre>\\n<p>NOTE: You may come across \\"anyfunc\\" or \\"anyref\\" in the future. These are deprecated - ignore them.</p>\\n<p>Call $send_extern_ref and $send_func_ref in $main</p>","exerciseCode":"(module\\n  (import \\"env\\" \\"sendFuncRef\\" (func $send_func_ref (param funcref)))\\n  (import \\"env\\" \\"sendExternRef\\" (func $send_extern_ref (param externref)))\\n\\n  ;; import non-mutable externref and name it $global_extern_ref\\n  (import \\"env\\" \\"globalExternRef\\" (global $global_extern_ref externref))\\n\\n  ;; declare global funcref with initial value of null\\n  (global $global_func_ref funcref (ref.func $send_func_ref))\\n\\n  (func $main\\n    ;; TODO: call $send_func_ref and $send_extern_ref with correct params\\n  )\\n\\n  (export \\"main\\" (func $main))\\n)\\n","solutionCode":"(module\\n  (import \\"env\\" \\"sendFuncRef\\" (func $send_func_ref (param funcref)))\\n  (import \\"env\\" \\"sendExternRef\\" (func $send_extern_ref (param externref)))\\n\\n  ;; import non-mutable externref and name it $global_extern_ref\\n  (import \\"env\\" \\"globalExternRef\\" (global $global_extern_ref externref))\\n\\n  ;; declare global funcref with initial value of null\\n  (global $global_func_ref funcref (ref.func $send_func_ref))\\n\\n  (func $main\\n    (call $send_func_ref (global.get $global_func_ref))\\n    (call $send_extern_ref (global.get $global_extern_ref))\\n  )\\n\\n  (export \\"main\\" (func $main))\\n)\\n","testCode":"","hasWasm":false},{"id":"table","title":"Table","instructionsHtml":"<p>Tables can hold references. They use the syntax:</p>\\n<pre><code>(table $NAME SIZE funcref/externref)</code></pre>\\n<p>Elements are defined with</p>\\n<pre><code>(elem $table_id (START_INDEX) val1 val2 val3 ...)</code></pre>\\n<p>We can index into a table with (table.get) and store with (table.set).</p>\\n<p>If our table contains funcrefs, we can call functions stored in the table directly with <code>call_indirect</code> using the syntax:</p>\\n<pre><code>(call_indirect $table_id (type $func_type) (TABLE_INDEX) arg1 ...)</code></pre>\\n<p>Finish $call_func by calling the right function based off of the index.</p>","exerciseCode":"(module\\n  ;; Define custom type $custom_func_type to equal () => i32\\n  (type $custom_func_type (func (result i32)))\\n\\n  ;; import 4 functions of the same shape\\n  (import \\"env\\" \\"func1\\" (func $func1 (result i32)))\\n  (import \\"env\\" \\"func2\\" (func $func2 (result i32)))\\n  (import \\"env\\" \\"func3\\" (func $func3 (result i32)))\\n  (import \\"env\\" \\"func4\\" (func $func4 (result i32)))\\n\\n  ;; (table $name MIN_SIZE [MAX_SIZE] funcref/externref)\\n  (table $internal_funcs_table 4 funcref)\\n  (elem $internal_funcs_table (i32.const 0) $func1 $func2 $func3 $func4)\\n\\n  (func $call_func (param $table_index i32) (result i32)\\n    ;; TODO: Call the function indexed by $table_index in the table\\n  )\\n\\n  (export \\"callFunc\\" (func $call_func))\\n)","solutionCode":"(module\\n  ;; Define custom type $custom_func_type to equal () => i32\\n  (type $custom_func_type (func (result i32)))\\n\\n  ;; import 4 functions of the same shape\\n  (import \\"env\\" \\"func1\\" (func $func1 (result i32)))\\n  (import \\"env\\" \\"func2\\" (func $func2 (result i32)))\\n  (import \\"env\\" \\"func3\\" (func $func3 (result i32)))\\n  (import \\"env\\" \\"func4\\" (func $func4 (result i32)))\\n\\n  ;; (table $name MIN_SIZE [MAX_SIZE] funcref/externref)\\n  (table $internal_funcs_table 4 funcref)\\n  (elem $internal_funcs_table (i32.const 0) $func1 $func2 $func3 $func4)\\n\\n  (func $call_func (param $table_index i32) (result i32)\\n    (call_indirect $internal_funcs_table (type $custom_func_type) (local.get $table_index))\\n  )\\n\\n  (export \\"callFunc\\" (func $call_func))\\n)","testCode":"","hasWasm":false},{"id":"memory_dynamic","title":"Memory Dynamic","instructionsHtml":"<p>Memory can grow dynamically at runtime.</p>\\n<p>Some options:</p>\\n<pre><code>(memory.size) returns the current memory size in 64KB pages\\n(memory.grow N) attempts to grow by N pages, returns previous size or -1 on failure\\n(memory.fill DEST VALUE SIZE) fills SIZE bytes starting at DEST with VALUE</code></pre>\\n<p>Implement $init_and_size which:</p>\\n<pre><code>1. Grows memory by 1 page\\n2. Fills the first 10 bytes with the value 42\\n3. Returns the new memory size</code></pre>","exerciseCode":"(module\\n  (memory 1)\\n\\n  (func $init_and_size (result i32)\\n    ;; TODO: grow by 1 page, fill first 10 bytes with 42, return new size\\n  )\\n\\n  (export \\"memory\\" (memory 0))\\n  (export \\"initAndSize\\" (func $init_and_size))\\n)\\n","solutionCode":"(module\\n  (memory 1)\\n\\n  (func $init_and_size (result i32)\\n    ;; grow by 1 page, compute new size (prev + 1)\\n    (i32.add (memory.grow (i32.const 1)) (i32.const 1))\\n\\n    ;; fill first 10 bytes with 42\\n    (memory.fill (i32.const 0) (i32.const 42) (i32.const 10))\\n  )\\n\\n  (export \\"memory\\" (memory 0))\\n  (export \\"initAndSize\\" (func $init_and_size))\\n)\\n","testCode":"","hasWasm":false},{"id":"exceptions","title":"Exceptions","instructionsHtml":"<p>WebAssembly supports structured exception handling.</p>\\n<p>Define an exception tag:</p>\\n<pre><code>(tag $my_error (param i32))</code></pre>\\n<p>Throw an exception:</p>\\n<pre><code>(throw $my_error (VALUE))</code></pre>\\n<p>Handle exceptions with try_table:</p>\\n<pre><code>(block $catch_label (result i32)\\n  (try_table (result i32) (catch $my_error $catch_label)\\n    ... ;; code that might throw\\n  )\\n)</code></pre>\\n<p>When an exception is caught, control branches to $catch_label with the<br>exception payload on the stack.</p>\\n<p>Implement $safe_div which divides $a by $b, but throws error code 400<br>if $b is zero. The catch should return the error code.</p>","exerciseCode":"(module\\n  (tag $div_error (param i32))\\n\\n  (func $safe_div (param $a i32) (param $b i32) (result i32)\\n    ;; TODO: return a/b, or throw+catch error 400 if b is zero\\n  )\\n\\n  (export \\"safeDiv\\" (func $safe_div))\\n)\\n","solutionCode":"(module\\n  (tag $div_error (param i32))\\n\\n  (func $safe_div (param $a i32) (param $b i32) (result i32)\\n    (block $caught (result i32)\\n      (try_table (result i32) (catch $div_error $caught)\\n        ;; throw if b is zero\\n        (if (i32.eqz (local.get $b))\\n          (then (throw $div_error (i32.const 400)))\\n        )\\n        ;; otherwise return a / b\\n        (i32.div_s (local.get $a) (local.get $b))\\n      )\\n    )\\n  )\\n\\n  (export \\"safeDiv\\" (func $safe_div))\\n)\\n","testCode":"","hasWasm":false},{"id":"simd","title":"Simd","instructionsHtml":"<p>SIMD (Single Instruction, Multiple Data) processes multiple values at once.</p>\\n<p>The v128 type holds 128 bits, interpretable as:</p>\\n<pre><code>4 x i32, 8 x i16, 16 x i8, 2 x i64, 4 x f32, 2 x f64</code></pre>\\n<p>Load a vector from memory:</p>\\n<pre><code>(v128.load (i32.const OFFSET))</code></pre>\\n<p>Add two vectors (lane-wise):</p>\\n<pre><code>(i32x4.add (V1) (V2))</code></pre>\\n<p>Extract a single lane:</p>\\n<pre><code>(i32x4.extract_lane 0 (VEC))</code></pre>\\n<p>Implement $sum_lanes which loads a v128 of 4 i32s from memory offset 0<br>and returns their sum.</p>","exerciseCode":"(module\\n  (memory (export \\"memory\\") 1)\\n\\n  (func $sum_lanes (result i32)\\n    ;; TODO: load v128 from offset 0, extract all 4 lanes and add them\\n  )\\n\\n  (export \\"sumLanes\\" (func $sum_lanes))\\n)\\n","solutionCode":"(module\\n  (memory (export \\"memory\\") 1)\\n\\n  (func $sum_lanes (result i32)\\n    (i32.add\\n      (i32.add\\n        (i32x4.extract_lane 0 (v128.load (i32.const 0)))\\n        (i32x4.extract_lane 1 (v128.load (i32.const 0)))\\n      )\\n      (i32.add\\n        (i32x4.extract_lane 2 (v128.load (i32.const 0)))\\n        (i32x4.extract_lane 3 (v128.load (i32.const 0)))\\n      )\\n    )\\n  )\\n\\n  (export \\"sumLanes\\" (func $sum_lanes))\\n)\\n","testCode":"","hasWasm":false},{"id":"gc_types","title":"Gc Types","instructionsHtml":"<p>WebAssembly GC allows the host to manage memory for us.</p>\\n<p>Define a struct type:</p>\\n<pre><code>(type $type_name (struct (field $field_name1 i32) (field $field_name2 i32)))</code></pre>\\n<p>Create a struct instance:</p>\\n<pre><code>(struct.new $type_name (FIELD_VALUE1) (FIELD_VALUE2))</code></pre>\\n<p>Read a field:</p>\\n<pre><code>(struct.get $type_name $field_name (STRUCT_REF))</code></pre>\\n<p>Implement:</p>\\n<pre><code>- $make_point: creates a point with the given x and y values\\n- $get_x: extracts the x field from a point\\n- $get_y: extracts the y field from a point</code></pre>","exerciseCode":"(module\\n  (type $point (struct (field $x i32) (field $y i32)))\\n\\n  (func $make_point (param $x i32) (param $y i32) (result (ref $point))\\n    ;; TODO: create and return a new point\\n  )\\n\\n  (func $get_x (param $p (ref $point)) (result i32)\\n    ;; TODO: return the x field\\n  )\\n\\n  (func $get_y (param $p (ref $point)) (result i32)\\n    ;; TODO: return the y field\\n  )\\n\\n  (export \\"makePoint\\" (func $make_point))\\n  (export \\"getX\\" (func $get_x))\\n  (export \\"getY\\" (func $get_y))\\n)\\n","solutionCode":"(module\\n  (type $point (struct (field $x i32) (field $y i32)))\\n\\n  (func $make_point (param $x i32) (param $y i32) (result (ref $point))\\n    (struct.new $point (local.get $x) (local.get $y))\\n  )\\n\\n  (func $get_x (param $p (ref $point)) (result i32)\\n    (struct.get $point $x (local.get $p))\\n  )\\n\\n  (func $get_y (param $p (ref $point)) (result i32)\\n    (struct.get $point $y (local.get $p))\\n  )\\n\\n  (export \\"makePoint\\" (func $make_point))\\n  (export \\"getX\\" (func $get_x))\\n  (export \\"getY\\" (func $get_y))\\n)\\n","testCode":"","hasWasm":false}]}]'),e={chapters:n};export{n as chapters,e as default};
